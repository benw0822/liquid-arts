<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Messages - Liquid Arts</title>
    <link rel="stylesheet" href="css/styles.css?v=force">
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&family=Playfair+Display:wght@400;700&display=swap"
        rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>

<body class="light-mode">
    <nav class="navbar">
        <div class="container nav-content" style="display: flex; align-items: center; justify-content: space-between;">
            <a href="index.html" class="logo">
                <img src="assets/logo_horizontal.png" alt="Liquid Arts" class="logo-img">
            </a>

            <!-- Desktop Nav Links -->
            <div class="nav-links" style="margin-left: 2rem;">
                <a href="explore.html" class="nav-link">Explore</a>
                <a href="bars.html" class="nav-link">Bars</a>
                <a href="map.html" class="nav-link">Map</a>
                <a href="msg.html" class="nav-link active">Messages</a>
                <a href="about.html" class="nav-link">About</a>
            </div>

            <!-- Global Auth Button (Mobile & Desktop) -->
            <a href="profile.html" id="global-auth-btn" class="nav-link" aria-label="Profile"
                style="margin-left: auto; display: flex; align-items: center; justify-content: center; width: 40px; height: 40px; color: var(--text-accent);">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                    stroke="currentColor" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path>
                    <circle cx="12" cy="7" r="4"></circle>
                </svg>
            </a>
        </div>
    </nav>

    <main class="container" style="margin-top: 6rem; min-height: 80vh;">
        <!-- Auth Wall -->
        <div id="auth-wall" style="text-align: center; display: none; padding-top: 4rem;">
            <h2>Please Log In</h2>
            <p>You need to be logged in to view your messages.</p>
            <button onclick="window.login()" class="btn" style="margin-top: 1rem;">Login with Google</button>
        </div>

        <!-- User View -->
        <div id="user-view" style="display: none;">



            <div id="messages-loading" style="text-align: center; color: #888;">Loading conversations...</div>

            <!-- Messages Section -->
            <div id="messages-container"
                style="display: none; width: 100%; height: 100vh; display: flex; flex-direction: column;">

                <!-- Main Active Thread Area (Full Height) -->
                <div id="active-thread-container"
                    style="flex: 1; display: flex; flex-direction: column; overflow: hidden; position: relative;">
                    <!-- Active thread content injected here -->
                    <div id="empty-state-placeholder"
                        style="text-align: center; padding: 4rem; color: #888; display: none;">
                        Select a conversation to start chatting.
                    </div>
                </div>

                <!-- Hidden Thread List Modal -->
                <div id="thread-list-modal"
                    style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 2000; background: rgba(0,0,0,0.5);">
                    <div
                        style="background: white; width: 80%; max-width: 320px; height: 100%; padding: 20px; overflow-y: auto; box-shadow: 2px 0 10px rgba(0,0,0,0.1); animation: slideRight 0.3s ease;">
                        <div
                            style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                            <h3 style="margin: 0; font-size: 1.2rem;">Messages</h3>
                            <button onclick="document.getElementById('thread-list-modal').style.display='none'"
                                style="background: none; border: none; font-size: 1.5rem; cursor: pointer;">&times;</button>
                        </div>
                        <div id="thread-list-content">
                            <!-- List injected here -->
                        </div>
                    </div>
                </div>
                <style>
                    @keyframes slideRight {
                        from {
                            transform: translateX(-100%);
                        }

                        to {
                            transform: translateX(0);
                        }
                    }

                    /* Responsive Layout Overrides */
                    @media (min-width: 769px) {

                        /* Desktop: No Bottom Nav */
                        .chat-input-bar {
                            bottom: 0 !important;
                        }

                        .user-header {
                            /* On desktop, navbar is still 60px? Yes. */
                            top: 60px !important;
                            width: 100%;
                            max-width: 1000px;
                            margin: 0 auto;
                            /* Center if needed, but fixed left/right */
                            left: 50% !important;
                            transform: translateX(-50%);
                        }

                        .chat-input-bar {
                            width: 100%;
                            max-width: 1000px;
                            left: 50% !important;
                            right: auto !important;
                            transform: translateX(-50%);
                        }
                    }

                    @media (max-width: 768px) {

                        /* Mobile: Bottom Nav Visible (~58px) */
                        /* Header below top navbar (60px) */
                        .user-header {
                            top: 60px !important;
                        }

                        /* Input above bottom nav */
                        .chat-input-bar {
                            bottom: 58px !important;
                            padding-bottom: 10px !important;
                            /* Reset safe area if handled by nav */
                        }

                        .bubbles-container {
                            /* Adjust padding for mobile headers */
                            padding-top: 130px !important;
                        }
                    }
                </style>

                <div id="no-messages" style="display: none; text-align: center; color: #888; margin-top: 2rem;">
                    No messages yet. Start hopping to chat!
                </div>
            </div>

        </div>
    </main>

    <nav class="bottom-nav">
        <a href="explore.html" class="nav-item">
            <svg class="nav-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round"
                stroke-linejoin="round">
                <path d="M6 13L17 4"></path>
                <path d="M4 15L15 6"></path>
                <path d="M4 15L6 13"></path>
                <path d="M15 6L17 4"></path>
                <path d="M11 10L8 21"></path>
                <path d="M11 10L14 21"></path>
            </svg>
            <span>EXPLORE</span>
        </a>
        <a href="bars.html" class="nav-item">
            <svg class="nav-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round"
                stroke-linejoin="round">
                <path d="M12 21v-8"></path>
                <path d="M5 4l7 9 7-9H5z"></path>
                <path d="M7 21h10"></path>
            </svg>
            <span>BARS</span>
        </a>
        <a href="map.html" class="nav-item">
            <svg class="nav-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round"
                stroke-linejoin="round">
                <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path>
                <circle cx="12" cy="10" r="3"></circle>
            </svg>
            <span>MAP</span>
        </a>
        <a href="msg.html" class="nav-item active">
            <svg class="nav-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round"
                stroke-linejoin="round">
                <path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2z"></path>
            </svg>
            <span>MSG</span>
        </a>
        <a href="profile.html" class="nav-item">
            <svg class="nav-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round"
                stroke-linejoin="round">
                <path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"></path>
            </svg>
            <span>POCKET</span>
        </a>
    </nav>

    <script src="js/app.js?v=force"></script>
    <script src="js/hopping.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', async () => {
            const authWall = document.getElementById('auth-wall');
            const userView = document.getElementById('user-view');

            // New UI Elements
            const activeContainer = document.getElementById('active-thread-container');
            const emptyPlaceholder = document.getElementById('empty-state-placeholder');
            const threadListModal = document.getElementById('thread-list-modal');
            const threadListContent = document.getElementById('thread-list-content');

            const msgContainer = document.getElementById('messages-container');
            const loading = document.getElementById('messages-loading');
            const noMessages = document.getElementById('no-messages');

            // Pagination & State
            let allThreads = [];
            let activeThreadId = null; // Track selected partner ID
            let currentUser = null;

            // Auth Check
            const supabase = window.supabaseClient || window.supabase.createClient('https://cbmtgmcgpzguospmgntg.supabase.co', 'YOUR_KEY_IF_NEEDED');
            // Ensure global access for helper functions
            window.supabaseClient = supabase;

            const { data: { session } } = await supabase.auth.getSession();
            const user = session?.user;

            if (!user) {
                authWall.style.display = 'block';
                return;
            }

            // Logged In Setup
            userView.style.display = 'block';
            currentUser = user;

            // Helper: From Hopping.js (Ensure availability)
            window.viewHop = (hopId) => {
                // We need to fetch hop data if not locally available in a clean way, BUT
                // we probably have it in the thread context or cache.
                // For simplicity, we'll try to find it in the current thread data.
                let foundHop = null;
                for (const t of allThreads) {
                    if (t.hops && t.hops[hopId]) {
                        foundHop = t.hops[hopId];
                        break;
                    }
                }

                if (!foundHop || !window.showHoppingDetails) return;

                window.showHoppingDetails(
                    null,
                    foundHop.image_url,
                    foundHop.hopped_at || foundHop.created_at,
                    foundHop.rating,
                    foundHop.description,
                    foundHop.id,
                    foundHop.user_id,
                    true,
                    foundHop.bars?.title,
                    foundHop.bars?.id
                );
            };

            // Helper: Format Time
            const formatTime = (isoString) => {
                const date = new Date(isoString);
                return date.toLocaleString('en-US', { hour: 'numeric', minute: 'numeric', hour12: true, month: 'short', day: 'numeric' });
            };

            // --- Render Logic (Sticky Input + Drawer) ---
            const renderThreads = (refreshDOM = false) => {
                if (allThreads.length === 0) {
                    loading.style.display = 'none';
                    noMessages.style.display = 'block';
                    msgContainer.style.display = 'block';
                    return;
                }

                noMessages.style.display = 'none';
                msgContainer.style.display = 'block';

                // 1. Auto-select first thread if none selected
                if (!activeThreadId && allThreads.length > 0) {
                    activeThreadId = allThreads[0].partnerId;
                }

                // 2. Render Thread List Modal Content
                threadListContent.innerHTML = allThreads.map(t => {
                    const isActive = t.partnerId === activeThreadId;
                    const bg = isActive ? '#f9fafb' : 'white';
                    const lastMsg = t.messages[t.messages.length - 1];
                    const preview = lastMsg ? lastMsg.content : 'No messages';
                    const time = lastMsg ? formatTime(lastMsg.created_at) : '';

                    return `
                        <div onclick="window.switchThread('${t.partnerId}'); document.getElementById('thread-list-modal').style.display='none';" 
                             style="display: flex; align-items: center; gap: 12px; padding: 12px; border-bottom: 1px solid #f0f0f0; cursor: pointer; background: ${bg}; transition: background 0.2s;">
                            <img src="${t.partnerAvatar}" style="width: 48px; height: 48px; border-radius: 50%; object-fit: cover;">
                            <div style="flex: 1; overflow: hidden;">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <span style="font-weight: 600; color: #333;">${t.partnerName}</span>
                                    <span style="font-size: 0.75rem; color: #999;">${time}</span>
                                </div>
                                <div style="font-size: 0.85rem; color: #666; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${preview}</div>
                            </div>
                        </div>
                    `;
                }).join('');

                // 3. Render Active Thread (Sticky Input Layout)
                const activeThread = allThreads.find(t => t.partnerId === activeThreadId);

                if (!activeThread) {
                    activeContainer.innerHTML = '';
                    emptyPlaceholder.style.display = 'block';
                    return;
                } else {
                    emptyPlaceholder.style.display = 'none';
                }

                // Unique ID based on thread
                const threadContentId = `thread-content-${activeThread.partnerId}`;
                let currentContentEl = document.getElementById(threadContentId);

                // --- Build Thread Content ---
                let lastHopId = null;
                const bubblesHtml = activeThread.messages.map(m => {
                    // Robust ID comparison
                    const isMe = String(m.user_id) === String(user.id);
                    const align = isMe ? 'flex-end' : 'flex-start';
                    const bg = isMe ? (m.is_private ? '#d1e9ff' : '#e3f2fd') : '#f5f5f5';
                    const radius = isMe ? '12px 0 12px 12px' : '0 12px 12px 12px';
                    const border = m.is_private ? '1px solid #cce5ff' : 'none';
                    const time = formatTime(m.created_at);

                    // Context Header logic (same as before)
                    let contextHeader = '';
                    if (m.hopId && m.hopId !== lastHopId) {
                        const hop = activeThread.hops[m.hopId];
                        if (hop) {
                            const isMeHeader = String(m.user_id) === String(user.id);
                            const headerAlign = isMeHeader ? 'flex-end' : 'flex-start';
                            const headerBg = isMeHeader ? '#e3f2fd' : '#f5f5f5';
                            const headerColor = '#555';

                            contextHeader = `
                                <div style="width: 100%; display: flex; flex-direction: column; align-items: ${headerAlign}; margin: 24px 0 6px 0;">
                                    <div style="background: ${headerBg}; border: 1px solid rgba(0,0,0,0.06); border-radius: 16px; padding: 6px 12px; display: flex; align-items: center; gap: 10px; font-size: 0.85rem; color: ${headerColor}; cursor: pointer; max-width: 90%; width: fit-content; box-shadow: 0 1px 3px rgba(0,0,0,0.05); transition: transform 0.2s;" 
                                         onclick="window.viewHop('${hop.id}')"
                                         onmouseover="this.style.transform='scale(1.02)'" onmouseout="this.style.transform='scale(1)'">
                                        <img src="${hop.image_url}" style="width: 48px; height: 48px; border-radius: 8px; object-fit: cover; flex-shrink: 0; border: 1px solid rgba(0,0,0,0.1);">
                                        <div style="display: flex; flex-direction: column;">
                                            <span style="font-size: 0.7rem; color: #888; text-transform: uppercase; letter-spacing: 1px;">Topic</span>
                                            <span style="font-weight: 700; color: #333; font-size: 0.95rem;">${hop.bars?.title || 'Unknown Bar'}</span>
                                        </div>
                                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-left: auto; color: #999;"><polyline points="9 18 15 12 9 6"></polyline></svg>
                                    </div>
                                </div>
                            `;
                        }
                        lastHopId = m.hopId;
                    }

                    // Bar Card Parsing
                    let messageContentHtml = m.content;
                    let isBarCard = false;
                    try {
                        // Optimistic check: starts with json-ish
                        if (m.content.trim().startsWith('{')) {
                            const parsed = JSON.parse(m.content);
                            if (parsed.type === 'bar_card' && parsed.data) {
                                isBarCard = true;
                                const bar = parsed.data;
                                messageContentHtml = `
                                    <div style="display: flex; flex-direction: column; width: 220px; overflow: hidden; cursor: pointer;" onclick="window.location.href='bar-details.html?id=${bar.id}'">
                                        <div style="width: 100%; height: 140px; background: #eee;">
                                            <img src="${bar.image || 'assets/default_bar.jpg'}" style="width: 100%; height: 100%; object-fit: cover; display: block;">
                                        </div>
                                        <div style="padding: 12px; background: white; border-top: 1px solid #f0f0f0;">
                                            <div style="font-weight: 700; font-size: 1rem; color: #1b1b1b; margin-bottom: 4px;">${bar.title}</div>
                                            <div style="font-size: 0.8rem; color: #bg-red; text-transform: uppercase; letter-spacing: 0.05em; display: flex; align-items: center; gap: 4px;">
                                                <span>View Bar</span>
                                                <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M5 12h14M12 5l7 7-7 7"/></svg>
                                            </div>
                                        </div>
                                    </div>
                                `;
                            }
                        }
                    } catch (e) {
                        // Not JSON, ignore
                    }

                    // Card Styling overrides
                    const bubbleBg = isBarCard ? 'white' : bg;
                    const bubblePad = isBarCard ? '0' : '8px 12px';
                    // Remove radius for card images if desired, or keep rounded bubble
                    const bubbleOverflow = isBarCard ? 'hidden' : 'visible';

                    return `
                         ${contextHeader}
                         <div style="display: flex; flex-direction: column; align-items: ${align}; width: 100%; margin-bottom: 4px;">
                             <div style="background: ${bubbleBg}; border: ${border}; padding: ${bubblePad}; border-radius: ${radius}; font-size: 0.95rem; color: #333; max-width: 85%; box-shadow: 0 1px 2px rgba(0,0,0,0.05); position: relative; word-break: break-word; overflow: ${bubbleOverflow};">
                                 ${messageContentHtml}
                             </div>
                             <div style="font-size: 0.65rem; color: #999; margin-top: 2px; margin-right: 4px; margin-left: 4px;">${time}</div>
                         </div>
                     `;
                }).join('');

                // Sticky Layout Structure
                const innerHTML = `
                     <!-- Fixed Header (Viewport Fixed) -->
                     <!-- top: 60px to sit below main navbar -->
                     <div class="user-header" style="position: fixed; top: 60px; left: 0; right: 0; background: rgba(255,255,255,0.98); backdrop-filter: blur(10px); z-index: 800; display: flex; align-items: center; gap: 12px; padding: 12px 16px; border-bottom: 1px solid #eee; box-shadow: 0 1px 2px rgba(0,0,0,0.03); height: 64px;">
                        <button onclick="document.getElementById('thread-list-modal').style.display='block'" 
                                style="background: none; border: none; padding: 8px; cursor: pointer; display: flex; align-items: center; justify-content: center; color: #333;">
                            <!-- Left Arrow Icon -->
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 12H5M12 19l-7-7 7-7"/></svg>
                        </button>
                        <img src="${activeThread.partnerAvatar}" style="width: 40px; height: 40px; border-radius: 50%; object-fit: cover; border: 1px solid #ddd;">
                        <div>
                            <div style="font-weight: 700; font-size: 1.1rem; color: #1b1b1b;">${activeThread.partnerName}</div>
                            <div style="font-size: 0.8rem; color: #888;">${activeThread.messages.length} messages</div>
                        </div>
                     </div>

                     <!-- Scrollable Messages Area -->
                     <div class="bubbles-container" style="flex: 1; overflow-y: auto; padding: 16px; padding-top: 134px; padding-bottom: 132px; display: flex; flex-direction: column;">
                         ${bubblesHtml}
                     </div>

                     <!-- Fixed Bottom Input -->
                     <!-- Sits on top of ~50px bottom nav. Container is transparent to hide layout gaps. -->
                     <div class="chat-input-bar" style="position: fixed; bottom: 50px; right: 0; left: 0; background: transparent; padding: 10px 16px; border-top: none; display: flex; align-items: center; gap: 10px; z-index: 1100; max-width: 1000px; margin: 0 auto; pointer-events: none;">
                         <!-- Suggestion Box (Absolute relative to this fixed container) -->
                         <div id="bar-suggestions-${activeThread.partnerId}" 
                              style="display: none; position: absolute; bottom: 100%; left: 16px; right: 16px; margin-bottom: 8px; background: white; border-radius: 12px; box-shadow: 0 -4px 20px rgba(0,0,0,0.15); max-height: 200px; overflow-y: auto; z-index: 1200; pointer-events: auto; border: 1px solid #eee;">
                         </div>

                         <input type="text" id="reply-input-${activeThread.partnerId}" 
                                class="reply-input"
                                placeholder="Type @ to search bars..." 
                                oninput="window.handleChatInput(event, '${activeThread.partnerId}')"
                                onkeydown="if(event.key === 'Enter') window.sendInlineReply('${activeThread.partnerId}')"
                                style="flex: 1; border: 1px solid #ddd; border-radius: 24px; padding: 12px 16px; font-size: 16px; outline: none; background: white; color: #333; transition: border 0.2s; pointer-events: auto; box-shadow: 0 4px 15px rgba(0,0,0,0.1);">
                         <button onclick="window.sendInlineReply('${activeThread.partnerId}')" 
                                 style="background: var(--bg-red); color: white; border: none; border-radius: 50%; width: 44px; height: 44px; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: transform 0.2s; box-shadow: 0 4px 6px rgba(239, 68, 68, 0.3); pointer-events: auto;">
                             <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>
                         </button>
                     </div>
                `;

                // Add Bar Search Logic if not exists - DO NOT REDECLARE if simple re-render
                if (!window.handleChatInput) {
                    window.handleChatInput = async (e, partnerId) => {
                        const val = e.target.value;
                        const suggestBox = document.getElementById(`bar-suggestions-${partnerId}`);

                        // Check for @ trigger
                        // We want to capture everything after the last @ to allow spaces/Chinese
                        const lastAtIndex = val.lastIndexOf('@');

                        if (lastAtIndex !== -1) {
                            // Extract query string after @
                            const query = val.slice(lastAtIndex + 1);

                            // Optional: Only trigger if @ is at the start or preceded by space?
                            // For now, let's allow it anywhere for flexibility.

                            suggestBox.innerHTML = '<div style="padding:12px; text-align:center; color:#888;">Searching...</div>';
                            suggestBox.style.display = 'block';

                            // Construct Query
                            let rpc = window.supabaseClient
                                .from('bars')
                                .select('id, title, hero_image')
                                .limit(5);

                            // If query exists, filter. If empty, show latest.
                            if (query) {
                                rpc = rpc.ilike('title', `%${query}%`);
                            } else {
                                rpc = rpc.order('created_at', { ascending: false });
                            }

                            const { data: bars, error } = await rpc;

                            if (error) {
                                console.error('Bar search error:', error);
                                suggestBox.innerHTML = `<div style="padding:12px; text-align:center; color:red; font-size:0.8rem;">Error: ${error.message}</div>`;
                                return;
                            }

                            if (bars && bars.length > 0) {
                                suggestBox.innerHTML = bars.map(bar => `
                                    <div onclick='window.selectBarForChat("${partnerId}", ${JSON.stringify(bar).replace(/'/g, "&#39;")})' 
                                         style="display: flex; align-items: center; gap: 10px; padding: 10px 12px; border-bottom: 1px solid #f5f5f5; cursor: pointer; transition: background 0.2s;"
                                         onmouseover="this.style.background='#f9f9f9'" onmouseout="this.style.background='white'">
                                        <img src="${bar.hero_image || 'assets/default_bar.jpg'}" style="width: 32px; height: 32px; border-radius: 6px; object-fit: cover;">
                                        <span style="font-weight: 600; color: #333; font-size: 0.9rem;">${bar.title}</span>
                                    </div>
                                `).join('');
                            } else {
                                suggestBox.innerHTML = '<div style="padding:12px; text-align:center; color:#888; font-size:0.8rem;">No bars found</div>';
                            }
                        } else {
                            suggestBox.style.display = 'none';
                        }
                    };

                    window.selectBarForChat = (partnerId, bar) => {
                        const payload = JSON.stringify({
                            type: 'bar_card',
                            data: {
                                id: bar.id,
                                title: bar.title,
                                image: bar.hero_image
                            }
                        });
                        // Send immediately
                        window.sendInlineReply(partnerId, null, payload);

                        // Clear input
                        const input = document.getElementById(`reply-input-${partnerId}`);
                        if (input) input.value = '';
                        document.getElementById(`bar-suggestions-${partnerId}`).style.display = 'none';
                    };
                }

                if (!currentContentEl) {
                    activeContainer.innerHTML = `<div id="${threadContentId}" style="height: 100%; display: flex; flex-direction: column;">${innerHTML}</div>`;

                    const bubbles = document.querySelector('.bubbles-container');
                    if (bubbles) setTimeout(() => bubbles.scrollTo({ top: bubbles.scrollHeight }), 50);
                } else {
                    const activeEl = document.activeElement;
                    const isFocused = currentContentEl.contains(activeEl);
                    const currentVal = isFocused ? activeEl.value : '';

                    currentContentEl.innerHTML = innerHTML;

                    if (isFocused) {
                        const input = document.getElementById(`reply-input-${activeThread.partnerId}`);
                        if (input) {
                            input.value = currentVal;
                            input.focus();
                        }
                    }
                    const bubbles = currentContentEl.querySelector('.bubbles-container');
                    if (bubbles) setTimeout(() => bubbles.scrollTo({ top: bubbles.scrollHeight }), 50);
                }

                loading.style.display = 'none';
            };

            // Switch Logic
            window.switchThread = (partnerId) => {
                activeThreadId = partnerId;
                renderThreads(true);
            };


            // --- Fetch Logic (User Centric) ---
            const fetchThreads = async () => {
                try {
                    if (allThreads.length === 0) loading.style.display = 'block';

                    // 1. Fetch Related Hops IDs
                    // We need to know about any hop we touched.
                    const relevantHopIds = new Set();

                    // A. My Hops
                    const { data: myHops } = await window.supabaseClient.from('hoppings').select('id').eq('user_id', user.id);
                    if (myHops) myHops.forEach(h => relevantHopIds.add(h.id));

                    // B. Comments I made
                    const { data: myComments } = await window.supabaseClient.from('hopping_comments').select('hopping_id').eq('user_id', user.id);
                    if (myComments) myComments.forEach(c => relevantHopIds.add(c.hopping_id));

                    // C. DMs (sent or received)
                    // Note: DMs might have related_hop_id OR be null.
                    const { data: myMsgs } = await window.supabaseClient.from('private_messages')
                        .select('related_hop_id, sender_id, receiver_id')
                        .or(`sender_id.eq.${user.id},receiver_id.eq.${user.id}`);

                    let interactors = new Set();

                    if (myMsgs) {
                        myMsgs.forEach(m => {
                            if (m.related_hop_id) relevantHopIds.add(m.related_hop_id);
                            if (m.sender_id !== user.id) interactors.add(m.sender_id);
                            if (m.receiver_id !== user.id) interactors.add(m.receiver_id);
                        });
                    }

                    const hopIds = Array.from(relevantHopIds);

                    // 2. Fetch Hops Metadata (Titles, Images)
                    let hopsMap = {};
                    if (hopIds.length > 0) {
                        const { data: hopsData } = await window.supabaseClient.from('hoppings')
                            .select('*, bars (id, title, location)')
                            .in('id', hopIds);

                        if (hopsData) {
                            hopsData.forEach(h => {
                                hopsMap[h.id] = h;
                                interactors.add(h.user_id); // Owner is interactor
                            });
                        }
                    }

                    // 3. Fetch Comments (as messages)
                    let interactions = [];
                    if (hopIds.length > 0) {
                        const { data: cData } = await window.supabaseClient.from('hopping_comments')
                            .select('id, hopping_id, content, created_at, user_id')
                            .in('hopping_id', hopIds)
                            .order('created_at', { ascending: true });

                        if (cData) {
                            cData.forEach(c => {
                                if (c.user_id !== user.id) interactors.add(c.user_id);
                                // Is this comment relevant? 
                                // Only if it's on MY hop OR I commented on this hop?
                                // Simplified: If I am owner, ALL comments are relevant.
                                // If I am NOT owner, only comments by ME or OWNER are relevant (simulating DM).
                                // Current logic: We treat comments as semi-public DMs between Owner and Commenter.

                                const hop = hopsMap[c.hopping_id];
                                if (!hop) return;

                                const amOwner = hop.user_id === user.id;
                                let partner = null;

                                if (amOwner) {
                                    // Me (Owner) <-> Commenter
                                    if (c.user_id === user.id) return; // Ignore my own comments for "incoming" check?
                                    // Actually, we want to see threads.
                                    // If user_id is ME, who is the partner?
                                    // In a public comment section, "partner" is ambiguous if filtered this way. 
                                    // But typically: Thread = (Owner + Specific User).
                                    // So if I am Owner, I see threads for each Commenter.
                                    partner = c.user_id;
                                } else {
                                    // Me (Commenter) <-> Owner
                                    if (c.user_id === user.id) {
                                        partner = hop.user_id;
                                    } else if (c.user_id === hop.user_id) {
                                        partner = hop.user_id; // Owner replied
                                    } else {
                                        // Third-party comment on thread I'm in? 
                                        // Ignore for now to keep 1:1 feel.
                                        return;
                                    }
                                }

                                if (partner) {
                                    interactions.push({
                                        ...c,
                                        type: 'comment',
                                        hopId: c.hopping_id,
                                        partnerId: partner,
                                        is_private: false
                                    });
                                }
                            });
                        }
                    }

                    // 4. Fetch Messages (DMs)
                    if (myMsgs) { // We have raw msgs, need content
                        const { data: pData } = await window.supabaseClient.from('private_messages')
                            .select('id, sender_id, receiver_id, content, created_at, related_hop_id')
                            .or(`sender_id.eq.${user.id},receiver_id.eq.${user.id}`)
                            .order('created_at', { ascending: true });

                        if (pData) {
                            pData.forEach(m => {
                                const partner = m.sender_id === user.id ? m.receiver_id : m.sender_id;
                                interactions.push({
                                    ...m,
                                    type: 'private',
                                    hopId: m.related_hop_id,
                                    user_id: m.sender_id, // FIX: Map sender_id to user_id for rendering logic
                                    partnerId: partner,
                                    is_private: true
                                });
                            });
                        }
                    }

                    // 5. Fetch Users
                    const uniqueUserIds = Array.from(interactors);
                    let userMap = {};
                    if (uniqueUserIds.length > 0) {
                        const { data: uData } = await window.supabaseClient.from('users')
                            .select('id, name, hopper_nickname, hopper_image_url')
                            .in('id', uniqueUserIds);
                        if (uData) uData.forEach(u => userMap[u.id] = u);
                    }

                    // 6. Group by Partner
                    let threadsMap = {};
                    interactions.forEach(item => {
                        if (!threadsMap[item.partnerId]) {
                            const pUser = userMap[item.partnerId] || { name: 'User' };
                            threadsMap[item.partnerId] = {
                                partnerId: item.partnerId,
                                partnerName: pUser.hopper_nickname || pUser.name || 'Anonymous',
                                partnerAvatar: pUser.hopper_image_url || `https://ui-avatars.com/api/?name=${encodeURIComponent(pUser.name || 'User')}&background=random`,
                                messages: [],
                                hops: {}, // context cache
                                latestDate: new Date(0)
                            };
                        }

                        // Add context hop
                        if (item.hopId && hopsMap[item.hopId]) {
                            threadsMap[item.partnerId].hops[item.hopId] = hopsMap[item.hopId];
                        }

                        threadsMap[item.partnerId].messages.push(item);
                    });

                    // 7. Sort & Clean
                    let threadArray = Object.values(threadsMap);
                    threadArray.forEach(t => {
                        // Dedupe by ID + Type
                        const seen = new Set();
                        t.messages = t.messages.filter(m => {
                            const key = `${m.id}-${m.type}`;
                            if (seen.has(key)) return false;
                            seen.add(key);
                            return true;
                        });

                        t.messages.sort((a, b) => new Date(a.created_at) - new Date(b.created_at));
                        if (t.messages.length > 0) {
                            t.latestDate = new Date(t.messages[t.messages.length - 1].created_at);
                        }
                    });

                    threadArray.sort((a, b) => b.latestDate - a.latestDate);

                    allThreads = threadArray;
                    renderThreads(true);

                } catch (err) {
                    console.error('Fetch Error:', err);
                }
            };

            fetchThreads();


            // --- Send Logic ---
            window.sendInlineReply = async (partnerId, _, overrideContent) => {
                const inputEl = document.getElementById(`reply-input-${partnerId}`);
                let content = overrideContent ? overrideContent : (inputEl ? inputEl.value.trim() : '');

                if (!content) return;

                // Determine context: Use last message's hopId?
                // User requirement: "Grouped... but label hop".
                // If I just type in the box at the bottom, what is the context?
                // Logic: Look at last message. If it had a hopId, use it? 
                // OR: Default to generic DM (null) if simply replying to thread.
                // Let's use the LAST Hop Context if available to maintain flow, otherwise null.

                const thread = allThreads.find(t => t.partnerId === partnerId);
                let contextHopId = null;
                if (thread && thread.messages.length > 0) {
                    const lastMsg = thread.messages[thread.messages.length - 1];
                    if (lastMsg.hopId) contextHopId = lastMsg.hopId;
                }

                const tempMsg = {
                    id: 'temp-' + Date.now(),
                    content: content,
                    user_id: user.id,
                    created_at: new Date().toISOString(),
                    is_private: true,
                    hopId: contextHopId,
                    type: 'private'
                };

                // Optimistic UI
                if (thread) {
                    thread.messages.push(tempMsg);
                    thread.latestDate = new Date();
                    // Move to top
                    allThreads = allThreads.filter(t => t !== thread);
                    allThreads.unshift(thread);
                    renderThreads(true);
                }

                if (inputEl) inputEl.value = '';

                // API
                const payload = {
                    sender_id: user.id,
                    receiver_id: partnerId,
                    content: content,
                    related_hop_id: contextHopId
                };

                const { error } = await window.supabaseClient.from('private_messages').insert([payload]);

                if (error) {
                    alert('Error sending: ' + error.message);
                    fetchThreads(); // Revert
                }
            };
            // Realtime
            const channel = window.supabaseClient.channel('msg-page-realtime')
                .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'private_messages' }, () => fetchThreads())
                .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'hopping_comments' }, () => fetchThreads())
                .subscribe();

            window.login = async () => {
                const { error } = await window.supabaseClient.auth.signInWithOAuth({
                    provider: 'google',
                    options: { redirectTo: window.location.href }
                });
                if (error) alert(error.message);
            };
        });
    </script>
</body>

</html>